1) strlen возвращает size_t, а у нас идет присваивание char => возникает переполнение
и можно выйти в отрицательный диапазон. Для этого нужно просто передать строку немного длиннее чем 127 символов

2) По сути требуется вызвать переполнение при операции в условии. Этого можно добиться превысив максимальный размер uint и обнулив байты. Сделать это можно скомбинировав us и uc так, чтобы при суммировании с неким числом, они давали число на единицу большее макс значения uint, при этом они ограничены своими типами. тогда можно просто подобрать такие числа, с относительно маленьким произведением us и uc, например чтобы 4294967000 дополнить до 4294967296 нужно прибавить к нему 74*4 = 296.
Итого:
4294967000 74 4

3) Можно подобрать небольшое отрицательное число, например -100, которое в unsigned представлении будет больше 200

4) Опять же надо переполнением обнулить байты числа. Поскольку операнд = +2, то нужно передать
max(uint)-1 = 4294967294

5) В описании функции gets написано что "Чтение строки производится пока не будет встречен символ «переход на новую строку», или не будет достигнут конец файла", что по сути означает что запись не ограничена размером массива. Можно заметить что в стека переменная хранится непосредственно перед массивом, т.е. gets запишет 16-ый символ в этот байт. Нужно только чтобы его значение было не равно 5

6) По описанию: "OPEN_EXISTING - Открывает файл. Функция завершается ошибкой, если файл не существует". Значит нужно создать/найти такой файл. Я, например, создал текстовый документ "cmd.exe"
в папке Windows и передал пустую строку как параметр. Можно так же передать папку где лежит cmd от винды.

7) По сути нужно лишь "занулить" левый байт числа b, а остальные не пострадали. Этого можно добиться тем же способом что и 5), т.е. чтобы при копировании в buf один байт в стеке (левый байт b) был занят нулевым байтом единственный способ этого добиться без "загрязнения" других байт - занять его нуль-термом, передав массив длины 16, чтобы 17 байт был замыкающим '\0'.

8) Как говорит вики: "Функции семейства printf принимают список аргументов и их размер отдельным параметром (в строке форматирования). Несоответствие строки форматирования и переданных аргументов может приводить к непредсказуемому поведению, повреждению стека и выполнению произвольного кода.." Вообще говоря поведение компилятора в ситуации несоответсвия зависит от реализация, но я нашёл что реализация от Microsoft будет искать данные в стеке. Тогда можно попробовать при помощи printf вывести в формате i и позже считать в t. Этого можно добиться с помощью строки hex-формата "%x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x % x %x %x %x %x %x %x %x %x";

9) -

10) Поскольку функция зависит только от параметра пути, можно запустить программу через полное имя пути к exe, тогда длина строки будет больше 16, а поскольку по индексу 16 будет выход за границы массива как раз на переменную i, ей присвоится 0

11) Чтобы в нужной переменной получилось необходимое число, нужно добиться такого переполнения массива, чтобы заполнить и saved_ebp и saved_eip, это доп 8 байт. Т.е. нужна строка в 88 символов, последние из которых будут представлять собой 0x41424344. Этим числом являются последовательные символы ABCD. Однако память заполняется "справа-налево" по байтам, т.е.нужно передать отразить относительно середины значение байт, т.е. в конце будет DCBA.

12) main выводит адрес функции unreachable, а поскольку единственным способом выполнить "недостижимую" функцию является ручное нарушения стека вызовов, можно изменить адрес возврата main который распологается ниже аргументов main в стеке. Таким образом после завершения main произойдет вызов unreachable.
Чтобы это сделать надо "перекрыть" всю память в стеке массива и аргументов main, которые суммарно занимают 84 байт. Поэтому передаем 84 байт "мусора" и 4 байта адреса unreachable в обратном порядке, как в 11 номере. Проблема была в том что у адрес функции у меня представлялся с нулевыми первыми байтами, до чего я додумался не сразу. В итоге коды символов получились 15, 16, 64, 0.
